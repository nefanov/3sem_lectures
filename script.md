3 семестр информатики -- это курс "Операционные системы", который следовало бы озаглавить "Введение в ОС". Материала много, занятий -- мало.

Курс, в особенности лекционный материал, посвящен основным принципам построения и функционирования операционных систем.
Теоретический материал составлен таким образом, чтобы абстрагироваться от конкретной ОС, хотя на практике, да и местами на лекциях, мы будем рассматривать Unix-подобные ОС на примере Linux.

Мы рассмотрим не всё, и за большим нужно обращаться к литературе:

Литература:

1) Карпов, Коньков, 2-е (3-е) изд. 
2) Э. Таненбаум, Х. Бос "Современные ОС"
3) Керриск "Линукс API: исчерпывающее руководство"
4) Avi Silbershatz, Operating System Concept, 2018.

ОС абстрагирует программиста от своего внутреннего устройства и от железа, предоставляя абстрактный интерфейс, который, как правило, хорошо стандартизован, обратно совместим и эффективен.

1-й период эволюции.
==

Программирование в тот период -- переключение логических вентилей, составленных из вакуумно-электронных элементов (ламп). Отладка -- ручной поиск перегоревших ламп, ошибок в схемах и т.д. Все сотрудники, работающие с компьютером -- инженеры-вычислители, разделения труда нет.
Возникновение первых компиляторов (с ассемблера в машинные коды)
Операционных систем не существует.
Основной результат -- становление архитектуры фон Неймана. Данные и код теперь лежат в одной памяти.

2-й период эволюции.
== 
Переход к полупроводниковой электронике. 
Взлёт алгоритмических ЯП. Формируется каста программистов. Это люди, которые заняты исключительно программированием -- созданием, тестированием и отладкой программ.
Многократно переиспользованный код стали сохранять на перво(или магнитные) ленты, и загружать в память машины автоматически. Так появились библиотеки. Программы, требующие одних и тех же библиотек, стали собирать вместе и ставить на исполнение. Так появились пакеты.

3-й период эволюции.
== 
Переход к интегральным схемам -- несколько логических элементов на кристалле. 
I/O выносят в отдельные аппаратные блоки, таким образом процессор занят в основном вычислениями, а не вводом-выводом. Использование спулинга через жесткие диски.

Формируется ряд концепций ОС, которые мы наблюдаем и сейчас:

* По хорошему, программе нужно запретить ходить в чужую память. Следовательно, нужна изоляция памяти.

* Также при переключении между программами нужно сохранять-восстанавливать состояние этих программ -- возникает понятие контекста (память + содержимое регистров + ...)

* Если бы пользовательские программы напрямую занимались вводом-выводом, это бы занимало кучу времени -- вместо выполнения вычислений, программа что-то пишет или читает из устройства, при этом остальные программы ждут. Следовательно, нужно запретить пользовательским программам ...

- Привилегированные команды -- только программа координатор (Ядро ОС), пользовательские команды не имеют права их выполнять напрямую.
Значит, нужно уметь просить координатора следать то или иное действие -- системные вызовы -- точки входа в координатор, обращаясь к которым, пользовательские программы могут выполнить ...

- Непривилегированные команды -- любые программы
* Прерывания... -- основной аппаратный механизм, позволяющий реализовать ОС (обработка событий, приходящих асинхронно).



* Иногда программа состоит из нескольких одновременно работающих программ, нужно передавать данные от 1 к 2. То есть нужны примитивы межпрограммного взаим.

* Если порядок важен, нужны примитивы синхронизации.

ОС == мультипрограммная пакетная система на этом этапе.

+ мультипрограммность -- переосмысление (вытесняющая многозадачность). Квант времени -- переход к системам разделения времени. Переключение происходит не только если программе нужно переключиться, а и по истечении кванта времени.

* возникает идея о том, что в памяти можно хранить только ту часть программы и данных, которая нам нужна сейчас (+ подкачка).
* Создание иллюзии монопольной работы -- виртуальная память. Строится отображение физической памяти во множество адресов, доступных программе при работе. В результате, физической памяти может быть много меньше, чем виртуальной.
* Развитие интерактивных систем, в особенности, систем отладки.
* Появляется понятие файловой системы как способа организации файлов на диске

В то время софт переписывался от поколения системы к системе. И возникла идея объединять машины в семейства. С совместимостью и т.д.

4-й период эволюции.
==

Большие интегральные схемы -- целый процессор на кристалле. Персональные компьютеры. Интерфейс взаимодействия с пользователем.
Происходит резкая деградация ОС для таких компьютеров. Всё переходит на уровень однопрограммных интерактивных систем.
По мере роста объемов вычислений происходит обратно переход. ПК становится мультипользовательскими.

Начинается массовое объединение компьютеров в сети. Появляется понятие сетевых и распределенных ОС -- способ обеспечивающий работу пользователя на компьютере в сети.

5-й период эволюции.
==
Многоядерные процессоры. HPC. Системы на кристаллах. Мобильные системы. Виртуализация.

Сервисы ОС:
==

Необходимо у пользователя создать иллюзию того, что он один использует компьютер.

Работу пользователя на ранних этапах развития ОС заменяет процесс.

Абстракция виртуальной памяти позсоляет изолировать разные программы, и программы и ОС.

Обработка ошибок -- ошибки в программах не должны валить систему.

Модель безопасности (пользователи, права, группы), модели группировки процессов (сессии, группы, контейнеры).

ОС позволяет пользователям и программистам получить высокоуровневые абстракции (в виде АПИ), чтоб не думать, что там под ней лежит.

Основные сервисы ОС:
==

- Планировка задач
- Управление памятью
- IPC

Абстракции, предоставляемые ОС:
==
* Процессы, потоки
* Виртуальное адресное пространство -- процесс имеет полный диапазон адресов, не связанных с другим процессом (даже если за ними нет никакой памяти)
* Интерфейс системных вызовов
* Файлы и ФС
* Средства межпроцессного взаимодействия и синхронизации
* etc



Основные функции ОС.
==
* Планирование заданий и использование процессора
* Межпрограммная коммуникация
* Управление памятью
* Управление ФС
* Управление вводом-выводом
* Обеспечение безопасности

Эти функции сложились эволюционно-исторически. ОС -это просто разумный способ существования современных вычислительных систем.
Мы будем рассматривать эти функции в рамках нашего курса.


Архитектура ОС.
==
Монолитное ядро:
+ (+)просто и вычислительно эффективно
- (-)при добавлении \ удалении \ изменении -- необходимо перекомпилировать всё ядро (по крайней мере, перелинковать)
- (-)тяжело отлаживать и тестировать

Многоуровневые системы (монолит, разделенный на уровни): -- в настоящее время используются только для отдельных компонент (например, сетевой стек)
+ (+)Упрощает тестирование, отладку
+ (+)Уровень можно заменить
- (-)Медленнее

Микроядерная архитектура:
Микроядро работает в привилегированном режиме. Абстракции типа ФС и т.д. наворачиваются уже над микроядром. Остальные части системы -- в пространстве пользователя. Взаимодействие происходит путем передачи сообщений через микроядро.
+ (+)требует меньше оперативной памяти
+ (+)проектировать проще, чем многоуровневые
- (-)Работает крайне медленно. Узкое место по производительности -- микроядро. 
+ (+)Просто отлаживать

В реальности, нет "чистых" реализаций:
* Линукс -- это монолитное ядро с поддержкой модулей, которые работают в привилегированном режиме в адресном пространстве ядра. То есть это гибридная архитектура.
* Виндовз -- утверждается, что Виндовз НТ -- это микроядро, но они по ходу работы туда ввинтили очень много функциональности, и по факту микроядро таковым быть перестало.

Вообще -- практика - лучший судья, вот поэтому чистых архитектур на практике не существует.

Виртуальные машины.
==

Процесс.
==

Процесс--абстракция, создающая иллюзию монопольного использования компьютера запущенной программе.

Иными словами, процесс -- это способ предоставления программе окружения исполнения:

- Адресное пространство
- Таблица файловых дескрипторов
- Набор процессоров
- Состояние == состояние памяти + содержимое регистров
- Системные атрибуты
- и т.д.

То есть процесс -- это "контейнер ресурсов".

Поток--абстракция, описывающее исполнение программы: состояние в каждый момент исполнения.

Технически, поток -- это поток исполнения -- это _как_ исполняется программа == стек + регистры + некоторые системные атрибуты (thread ID, etc).

У набора потоков в одном процессе -- общий набор ресурсов, который они разделяют между собой. Это может быть память, может быть набор сокетов и т.д.


Состояния процесса
==

Помимо накладных расходов, есть еще одна причина.

... Конечно, мы могли бы периодически опрашивать процессы, находящиеся в состоянии "Ожидание", но есть ещё и мотивация снижать энергопортребление -- если готовых процессов нет, процессор мог бы уснуть, а он вынужден был бы опрашивать очередь процессов. Поэтому, нужно выделить "ожидание", а выводить из него только проверив, что событие, которое процесс ждёт, состоялось.



Зачем же нужно состояние "завершен" -- чтобы узнать, как завершился процесс -- успешно или неуспешно?
Информация (екзит-код) хранится во внутренних структурах ядра, пока родитель не вычитает информацию, как умер его ребенок.

еxit(xxx) (and return from main)
info of signal
