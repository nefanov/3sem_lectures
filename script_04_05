Потоки (окончание).
==

Есть ОС, в которых поддержка потоков реализована на уровне ядра (См. линукс с clone). А есть где только в пространстве пользователя.

Если потоки поддержаны ядром, то ресурсы выделяются попроцессно -- всем нитям исполнения, а вот время исполнения выделяется попоточно.

Если же на уровне библиотек -- ядро считает, что есть только процессы. В этом случае время выделяется процессу целиком, а пользовательская библиотека сама должна разделять время между потоками.

Идея потоков круто стрельнула, когда появились многоядерные системы -- псевдопараллелизм превратился в настоящий параллелизм.

Алгоритмы синхронизации
==

Итак, ОС должна обеспечить санкционированное взаимодействие между процессами. Но нужно ли что-то менять в самих процессах, если они взаимодействуют?

Пример: у нас есть БД, и мы написали программу для работы с ней. В 1 процесс проблем нет.
Но если у нас процессов несколько, то процессы могут взаимодействовать, даже не зная об этом.

1) Активности и атомарные операции. Активность -- _последовательное_ выполнение ряда действий, направленных на достижение определенной цели.

Приготовление бутерброда:

1-2-3-4 -- атомарные операции. Если исполннитель выполняет такую операцию, он не имеет права переключаться на другое действие, пока текущая операция не будет завершена.

Если уже приступил к выполнению действия, то не отвлекаешься, пока не закончишь его.

Допустим, у нас есть активность P={a,b,c}, Q={d,e,f}. Если нам надо достичь обеих целей, то можем
выполнить в порядке PQ: abcdef.

Но если отдельные действия выполняются долго, то мы, в условиях разделения времени, могли бы переключаться между активностями, сохраняя при этом порядок действий, присущих каждой активности.
Например, abdcef, adbecf... У нас происходит перемешивание атомарных операций различных активностей, но порядок в рамках одной активности сохраняется -- b не может выполниться раньше a.

Это называется интерливингом. И он вполне может быть достигнут в системе с разделения времени.

Вопрос: при любом ли порядке в интерливинге мы придем к нужному результату?

Набор активностей, на которых при одних и тех же исходных данных при различном порядке в интерливинге возможны различные результаты на выходе, называется _недетерминированным_ набором.

С точки зрения ВС, процессы, составляющие детерминированный набор, предпочтительнее для выполнения в режиме разделения времени, а недетерминированный -- нежелательны.

Есть ли возможность проверить детерминированность, просто посмотрев на набор, не исполняя его. Строго и полностью алгоритмически эту задачу решить нельзя. 
Но есть условия Бернстайна -- если они удовлетворены, набор детерминирован. В противном случае ничего сказать нельзя.

Условия Бернстайна
==

Опр: входные данные операции -- то, что используется для вычилсения результата, выходные -- что получаем в ходе вычисления.



Вход данных активности -- объединение всех входных данных операций данной активности. То же самое для выходных.


Для 2 активностей P,Q:

1) W(P)\cap{W(q)} = \emptyset
2) W(P)\cap{R(q)} = \emptyset
3) R(P)\cap{W(q)} = \emptyset

То P,Q -- детерминированный набор. Это условие достаточное, но необходимое.


Как бороться с недетерминированностью -- ограничить количество вариантов чередования.

Состояние гонки
==

Состояние гонки -- использование недетерминированным набором общих ресурсов. Состояние гонки нет только на детерминированных наборах.


Взаимоисключение -- mutex
==

Mutual exclusion -- а давайте участки кода, в которых порядок важен, работает в режиме эксклюзивного доступа -- пусть ресурс захватывается, и пока мы не выполним на нем нужные действия, мы его не отпускаем.
Если очередность доступа не нужна, то мы получаем детерминированность.

А если очередность доступа важна, то нужна не толькоко взаимоисключение, а и _синхронизация_.

Критическая секция
==

Участок активности, выполнение которого может приводить к недетерминированности набора активности.

Когда удается организовать взаимоискл во время вып процессом кр секции, мы можем ликвидировать недетерминизм.

Нам придется вмешиваться в деятельность процессов, и снабжать их доп. действиями. (захватить - отпустить).

Конструирование алгоритмов синхронизации
==

Условие взаимоисключения: в критической секции одномоментно не более одного процесса в Г или И, таких, что IP тычет в код критической секции.

Условия прогресса: а) принятие решения, кто войдет в КС, определяют только процессы, готовые туда войти. б) время принятия решения конечны.

5) Process starwation не должно быть -- условие bound wait -- для любого процесса, желающего войти в КС, есть гарантированное время, после которого его пустят в КС.




